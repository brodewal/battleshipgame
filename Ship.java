import java.util.ArrayList;

public class Ship {
	
	/*
	 * Definitions of fields and methods 
	 */
	
	private String name;
	private Point head;
	private int length;
	private String orientation;
	
	public Ship(String n, Point p, int l, String o) {
		name = n;
		head = p;
		length = l;
		orientation = o;
	}
	
	public String getName() {
		return name;
	}
	
	/*
	 * You can infer the location of every portion of the same ship
	 * just by knowing the head coordinate, length of ship, 
	 * and orientation defined in the constructor.
	 */
	
	public ArrayList<Point> getOccupiedSpaces() {
		ArrayList<Point> locations = new ArrayList<Point>();
		for (int i = 0; i < length; i++) {
			
			switch (orientation) {
				case "Horizontal":
					locations.add(new Point(head.x+i,head.y));
					break;
				case "Vertical":
					locations.add(new Point(head.x, head.y+i));
					break;
				default:
					break;
			}
		}
		return locations;
	}
	
	/* checks if two ships' coordinates conflict
	 * or if a ship occupies one or more coordinates
	 * shared with another ship - so that the game code can reject a ship occupying pre-existing ship location
	 * (it is illegal to imply that a location is occupied by two ships)
	 */
	
	public static boolean collides(Ship ship1, Ship ship2) {
		ArrayList<Point> coordinatesOfShip1 = ship1.getOccupiedSpaces();
		ArrayList<Point> coordinatesOfShip2 = ship2.getOccupiedSpaces();
		
		for (int i = 0; i < coordinatesOfShip1.size(); i++) {
			for (int j = 0; j < coordinatesOfShip2.size(); j++) {
				if (coordinatesOfShip1.get(i).equals(coordinatesOfShip2.get(j)))
					return true;
			}
		}
		
		return false;
	}
	
	public boolean collides(Ship otherShip) {
		ArrayList<Point> coordinatesOfShip1 = this.getOccupiedSpaces();
		ArrayList<Point> coordinatesOfShip2 = otherShip.getOccupiedSpaces();
		
		for (int i = 0; i < coordinatesOfShip1.size(); i++) {
			for (int j = 0; j < coordinatesOfShip2.size(); j++) {
				if (coordinatesOfShip1.get(i).equals(coordinatesOfShip2.get(j)))
					return true;
			}
		}
		
		return false;
	}
	
	/*
	 * This method checks for damage of the ship
	 * i.e. how many of the ship's coordinates
	 * do not have an accompanying player shot
	 */
	
	public int hp(BattleshipGame bg) {
		ArrayList<Point> coordinatesOfShip = this.getOccupiedSpaces();
		ArrayList<Point> shotsCoordinates = bg.getShotsFired();
		
		int hp = length;
		for (int i = 0; i < coordinatesOfShip.size(); i++) {
			for (int j = 0; j < shotsCoordinates.size(); j++) {
				if (coordinatesOfShip.get(i).equals(shotsCoordinates.get(j)))
					hp--;
			}
		}
		return hp;
	}
	
	/*
	 * Checks for ship destroyed; that is, all ship coordinates also appear
	 * on the list of shots fired by player.
	 */
	
	public static boolean isSunk(Ship ship, BattleshipGame bg) {
		return ship.hp(bg) == 0;
	}
	
	public boolean isSunk(BattleshipGame bg) {
		return this.hp(bg) == 0;
	}
	
	public String toString() { //reveal spaces generated by ship definition
		ArrayList<Point> locations = getOccupiedSpaces();
		String s = name + " occupies the spaces: \n";
		for (int i = 0; i < locations.size(); i++) s += locations.get(i) + "\n";
		return s;
	}
	
	public static void main(String[] args ) { //test methods for ship definitions
		Ship ship = new Ship("Frigate", new Point(4,8), 5, "Horizontal");
		System.out.print(ship);
		Ship ship2 = new Ship("Air Carrier", new Point(5,0), 6, "Vertical");
		System.out.print(ship2);
	}
	

	
}
